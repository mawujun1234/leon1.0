<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"  
    xmlns:beans="http://www.springframework.org/schema/beans"   
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	xsi:schemaLocation="http://www.springframework.org/schema/beans   
	http://www.springframework.org/schema/beans/spring-beans-3.2.xsd    
	http://www.springframework.org/schema/security   
	http://www.springframework.org/schema/security/spring-security-3.1.xsd">  
    <!-- 
    <global-method-security pre-post-annotations="enabled"></global-method-security>  .
     -->
    <!-- 该路径下的资源不用过滤  
    <http pattern="/icons/**" security="none" />  
    <http pattern="/common/**" security="none" />  
    <http pattern="/ext-4/**" security="none" />  
    <http pattern="/login.jsp" security="none" />  
    --> 

    <!-- 这个id要和web.xml中的配置一样，否则会爆No bean named 'springSecurityFilterChain' is defined的异常 -->
    <!-- 一些路不进行过滤的配置还没有写 -->
    <beans:bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
	  <!--<filter-chain-map path-type="ant">
	     <filter-chain pattern="/**" filters="
	           securityContextPersistenceFilterWithASCTrue,
	           usernamePasswordAuthenticationFilter,
	           exceptionTranslationFilter,
	           filterSecurityInterceptor" />
	           
	  </filter-chain-map> 
	  -->
	  <beans:constructor-arg> 
	  	<beans:list>  
	  		<filter-chain pattern="/favicon.ico" filters="none"></filter-chain>
	  		<filter-chain pattern="/**/*.js" filters="none"></filter-chain>
	  		<filter-chain pattern="/icons/**" filters="none"></filter-chain>
	  		<filter-chain pattern="/common/**" filters="none"></filter-chain>
	  		<filter-chain pattern="/ext-4/**" filters="none"></filter-chain>
	  		<filter-chain pattern="/login.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/loginFailure.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/accessDeny.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/timeout.jsp" filters="none"></filter-chain>
	  		<!-- <filter-chain pattern="/j_spring_security_check" filters="none"></filter-chain> -->
	  		<!-- http://mark.koli.ch/2010/07/spring-3-and-spring-security-setting-your-own-custom-j-spring-security-check-filter-processes-url.html -->
            <filter-chain pattern="/**" filters="
               concurrentSessionFilter,
	           securityContextPersistenceFilterWithASCTrue,
	           logoutFilter,
	           usernamePasswordAuthenticationFilter,
	           rememberMeAuthenticationFilter,
	           sessionManagementFilter,
	           exceptionTranslationFilter,
	           filterSecurityInterceptor" />
        </beans:list>
       </beans:constructor-arg>
	</beans:bean>
	<!-- ======================================华丽的分割线==============================================-->
	<beans:bean class="org.springframework.security.web.context.SecurityContextPersistenceFilter" name="securityContextPersistenceFilterWithASCTrue">
		<!--true在过滤器开始之前保证session是可用的，默认是false -->
		<beans:property name="forceEagerSessionCreation" value="false"></beans:property>
		<!-- 安全上下文存放的地方 -->
		<beans:property name="securityContextRepository"  ref="securityContextRepository" />
	</beans:bean>
	<!-- 生成HttpSessionSecurityContextRepository ，它会把安全上下文保存为一个HttpSession的属性
	可选的是，你可以提供一个SecurityContextRepository接口的 null实现，这就可以防止安全上下文被保存，即使一个session已经在请求期间被创建了。-->  
    <beans:bean id="securityContextRepository"   class="org.springframework.security.web.context.HttpSessionSecurityContextRepository">  
        <beans:property name="allowSessionCreation" value="true" />  
        <beans:property name="disableUrlRewriting" value="false" />  
    </beans:bean>  
	<!-- ======================================华丽的分割线==============================================-->
	
	<beans:bean class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter" name="usernamePasswordAuthenticationFilter">
		<beans:property name="filterProcessesUrl" value="/j_spring_security_check"></beans:property><!-- 认证地址 -->
		<beans:property name="authenticationManager" ref="authenticationManager"></beans:property>
		<beans:property name="postOnly" value="false"></beans:property>
		<beans:property name="authenticationSuccessHandler"><!-- 认证成功的时候跳转-->
			<!-- <beans:bean class="org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler"> -->
			<beans:bean class="org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler">
				<beans:property name="defaultTargetUrl" value="/index.jsp"></beans:property>
				<beans:property name="requestCache" ref="httpSessionRequestCache"></beans:property>
			</beans:bean>
		</beans:property>
		<beans:property name="authenticationFailureHandler"><!-- 认证失败的时候跳转，还有ExceptionMappingAuthenticationFailureHandler根据不同的异常跳转到不同的也页面-->
			<!--  <beans:bean class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler">-->
			<beans:bean class="com.mawujun.user.login.ContentNavigationAuthenticationFailureHandler">
				<beans:property name="defaultFailureUrl" value="/loginFailure.jsp"></beans:property>
				<beans:property name="redirectStrategy" ref="redirectStrategy">
				</beans:property>	
				<!-- 是否使用forword来转发请求 ，使用forword的话，就可以再前台获取到请求数据和异常信息，默认是false
				<beans:property name="useForward" value="false"></beans:property>-->
			</beans:bean>
		</beans:property>
		<!-- session的并发控制 ，往SessionRegistry中注册会话信息，到时候可以供给concurrentSessionFilter判断是否已经过期，就可以跳转到过期页面了-->
		<beans:property name="sessionAuthenticationStrategy" ref="concurrentSessionControlStrategy"></beans:property>
		<!-- 当登录成功后，就记录登录成功信息 -->
		<beans:property name="rememberMeServices" ref="rememberMeServices"></beans:property>
	</beans:bean>
	<beans:bean name="redirectStrategy" class="com.mawujun.user.login.ContentNavigationDefaultRedirectStrategy"></beans:bean>
	<!-- 实现了UserDetailsService的Bean -->  
    <authentication-manager alias="authenticationManager">  
        <authentication-provider user-service-ref="userDetailsService">  
            <!-- 登入 密码  采用MD5加密 
            <password-encoder hash="md5" ref="passwordEncoder">  
            </password-encoder>   --> 
        </authentication-provider>  
        <!-- rememberMe的认证提供者 -->
        <authentication-provider ref="rememberMeAuthenticationProvider"></authentication-provider>
    </authentication-manager>  
    
    <!-- 自定义UserDetailsService认证  -->   
    <beans:bean id="userDetailsService"   class="com.mawujun.user.login.UserDetailsServiceImpl">  
        <beans:property name="userService" ref="userService"></beans:property>  
    </beans:bean>  
  
    <!-- 用户的密码加密或解密 -->  
    <beans:bean id="passwordEncoder"  
		class="org.springframework.security.authentication.encoding.Md5PasswordEncoder" />  
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 异常处理过滤器 --> 
	<beans:bean class="org.springframework.security.web.access.ExceptionTranslationFilter" name="exceptionTranslationFilter">
		<beans:constructor-arg>
			<!--
			<beans:bean class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">-->
			<beans:bean class="com.mawujun.user.login.ContentNavigationLoginUrlAuthenticationEntryPoint">
				<beans:property name="loginFormUrl" value="/login.jsp"></beans:property><!-- 没有认证的时候，跳转 -->
			</beans:bean>
		</beans:constructor-arg>
		<!-- 当访问拒绝或会话超期的时候（注意不包括会话失效），记录这次访问的请求，等重新登录后，就会返回这个请求，通过RequestCacheAwareFilter -->
		<beans:constructor-arg ref="httpSessionRequestCache"></beans:constructor-arg>
		
		<beans:property name="accessDeniedHandler"><!--访问局拒绝的时候跳转
			<beans:bean class="org.springframework.security.web.access.AccessDeniedHandlerImpl">-->
			<beans:bean class="com.mawujun.user.login.ContentNavigationAccessDeniedHandlerImpl">
				<beans:property name="errorPage" value="/accessDeny.jsp"></beans:property>
			</beans:bean>
		</beans:property>
	</beans:bean>
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 自定义认证管理,资源,权限   
	<beans:bean class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor" name="filterSecurityInterceptor"> -->
	<beans:bean class="com.mawujun.user.login.FilterSecurityInterceptorImpl" name="filterSecurityInterceptor">
		<beans:property name="authenticationManager" ref="authenticationManager"></beans:property>
		<beans:property name="accessDecisionManager">
			<beans:bean class="com.mawujun.user.login.AffirmativeBasedImpl">
				<!--取消了投票器，因为这里没有实现反向授权-->	
				<beans:property name="decisionVoters">
					<beans:list>
						<beans:bean class="org.springframework.security.access.vote.RoleVoter">
							<beans:property name="rolePrefix" value=""></beans:property>
						</beans:bean>
					</beans:list>
				</beans:property>		
			</beans:bean>
		</beans:property>
		<beans:property name="securityMetadataSource"><!-- 实现了角色资源的对应关系 -->
			<beans:bean class="com.mawujun.user.login.FilterInvocationSecurityMetadataSourceImpl">
				<beans:property name="roleService" ref="roleService"></beans:property>
				<!-- 必须要认证过才能访问的URL配置，roleService中获取的资源就表示认证后还不一定可以昂问，也就是说roleService的内容必须认证才能访问，但认证后不一定能访问roleService中返回的内容
				 这些地址之外的就表示无论谁都可以访问。-->
				 <!-- 这里还可以扩展/download/**这些内容必须是谁可以访问的，也可以做成在页面上动态配置 -->
				<beans:property name="needAuthenticationUrls">
					<beans:list>
						<beans:value>/**</beans:value>
					</beans:list>
				</beans:property>
			</beans:bean>
		</beans:property>
		<!-- 当某个资源被访问时，发现没有 授予角色时，也就是还没有进行分配的时候，是拒绝还是允许-->
		<beans:property name="rejectPublicInvocations" value="false"></beans:property>
	</beans:bean>
	
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 注销过滤器 -->
	<beans:bean id="logoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter">
		<beans:constructor-arg value="/login.jsp" />
		<beans:constructor-arg>
			<beans:array>
				<!-- 注销监听器  -->
				<beans:ref bean="logoutHandler" />	
				<!--注入rememberMeServices属性是为了安全退出的时候把记住密码的状态也删除了-->
				<beans:ref bean="rememberMeServices" />
			</beans:array>
		</beans:constructor-arg>
		<beans:property name="filterProcessesUrl" value="/j_spring_security_logout" />
	</beans:bean>
	<!-- 注销监听器,多个地方引用了  -->
	<beans:bean id="logoutHandler" class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"></beans:bean>

	<!-- ======================================华丽的分割线==============================================-->	
	<!-- SESSION固化保护,以及并发控制 -->
	<beans:bean id="sessionManagementFilter" class="org.springframework.security.web.session.SessionManagementFilter">
		<beans:constructor-arg name="securityContextRepository" ref="securityContextRepository" />
		<beans:property name="sessionAuthenticationStrategy" ref="concurrentSessionControlStrategy" />
	</beans:bean>

	<!-- SESSION并发数量等配置 -->
	<beans:bean id="concurrentSessionControlStrategy" class="org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy">
		<beans:constructor-arg name="sessionRegistry">
			<beans:ref bean="sessionRegistry" />	
		</beans:constructor-arg>
		<!-- 要求UserDetailsImpl实现hashCode和equals方法，来获取到唯一的对象 -->
		<beans:property name="maximumSessions" value="1" /><!-- 控制同个账号登录的次数，-1表示没有限制 -->
		<beans:property name="exceptionIfMaximumExceeded" value="false" /><!-- 表示将前面已经存在的用户强制过期，true表示后来的用户登录不了 -->
	</beans:bean>
	<beans:bean id="sessionRegistry" class="org.springframework.security.core.session.SessionRegistryImpl" />
	<!-- 过期会话的处理工作 -->
	<beans:bean id="concurrentSessionFilter" class="org.springframework.security.web.session.ConcurrentSessionFilter">
		<beans:constructor-arg ref="sessionRegistry">			
		</beans:constructor-arg>
		<!-- 这里的过期主要用于强制过期的时候，如果是web服务器过期是不会走这条线的。或者是同个账号不能同时登陆的时候，强制用户失效后再进行访问的时候跳转的页面 -->
		<beans:property name="expiredUrl" value="/timeout.jsp" />
		<beans:property name="redirectStrategy" ref="redirectStrategy"></beans:property>
		<beans:property name="logoutHandlers">
			<beans:list>
				<beans:ref bean="logoutHandler" />
				<!-- 这个要在 exceptionIfMaximumExceeded=false的时候配置，或者拥有强制用户失效（不是过期）-->
				<beans:bean class="com.mawujun.user.login.SavedRequestConcurrentSessionLogoutHandler">
					<beans:constructor-arg ref="httpSessionRequestCache"></beans:constructor-arg>
				</beans:bean>
			</beans:list>
		</beans:property>
	</beans:bean>
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 用于用户登录成功后，重新恢复因为登录被打断的请求,
	简单点说就是出现了AuthenticationException、AccessDeniedException两类异常 重新恢复：
	<beans:bean name="requestCacheAwareFilter" class="org.springframework.security.web.savedrequest.RequestCacheAwareFilter">
		<beans:constructor-arg ref="httpSessionRequestCache">
		</beans:constructor-arg>
	</beans:bean> 不需要这儿过滤器，
	1：只需要在UsernamePasswordAuthenticationFilter设置authenticationSuccessHandler为SavedRequestAwareAuthenticationSuccessHandler
	2： 设置ExceptionTranslationFilter的httpSessionRequestCache-->
	<!-- 存储上次请求的URL-->
	<beans:bean name="httpSessionRequestCache" class="org.springframework.security.web.savedrequest.HttpSessionRequestCache">
	</beans:bean>
	
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 记住密码功能(COOKIE方式) -->
	<beans:bean id="rememberMeAuthenticationFilter" class="org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter">
		<beans:property name="rememberMeServices" ref="rememberMeServices" />
		<beans:property name="authenticationManager" ref="authenticationManager" />
	</beans:bean>
	<!-- 一种是客户端记住用户名密码，一种是服务端记住用户名密码，现在采用的是客户端记住用户名密码 -->
	<beans:bean id="rememberMeServices" class="org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices">
		<beans:property name="userDetailsService" ref="userDetailsService" />
		<!-- 前台勾选是否记住用户名密码的参数，当 alwaysRemember=false的时候才会有用-->
		<beans:property name="parameter" value="rememberMe" />
		<!-- 表示肯定要记住用户名密码 -->
		<beans:property name="alwaysRemember" value="false"></beans:property>
		<!-- 默认时间604800秒(一个星期) -->
		<beans:property name="tokenValiditySeconds" value="604800" />
		<beans:property name="key" value="springRocks" />
	</beans:bean>
	<!--添加到 <authentication-manager alias="authenticationManager">中，作为第二种认证提供者的方式  -->
	<beans:bean id="rememberMeAuthenticationProvider" class="org.springframework.security.authentication.RememberMeAuthenticationProvider">
		<beans:property name="key" value="springRocks" />
	</beans:bean>
	
	<!-- DefaultWebInvocationPrivilegeEvaluator页面标签的权限 -->
	
    
</beans:beans> 