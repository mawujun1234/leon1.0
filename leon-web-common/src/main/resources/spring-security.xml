<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"  
    xmlns:beans="http://www.springframework.org/schema/beans"   
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="http://www.springframework.org/schema/beans   
	http://www.springframework.org/schema/beans/spring-beans-3.2.xsd    
	http://www.springframework.org/schema/security   
	http://www.springframework.org/schema/security/spring-security-3.2.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.2.xsd">  
    <!-- 
    <global-method-security pre-post-annotations="enabled"></global-method-security>  .
     -->
    <!-- 该路径下的资源不用过滤  
    <http pattern="/icons/**" security="none" />  
    <http pattern="/common/**" security="none" />  
    <http pattern="/ext-4/**" security="none" />  
    <http pattern="/login.jsp" security="none" />  
    --> 

    <!-- 这个id要和web.xml中的配置一样，否则会爆No bean named 'springSecurityFilterChain' is defined的异常 -->
    <!-- 一些路不进行过滤的配置还没有写 -->
    <beans:bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
	  <!--<filter-chain-map path-type="ant">
	     <filter-chain pattern="/**" filters="
	           securityContextPersistenceFilterWithASCTrue,
	           usernamePasswordAuthenticationFilter,
	           exceptionTranslationFilter,
	           filterSecurityInterceptor" />
	           
	  </filter-chain-map> 
	  -->
	  <beans:constructor-arg> 
	  	<beans:list>  
	  		<filter-chain pattern="/favicon.ico" filters="ipFilter"></filter-chain>
	  		<filter-chain pattern="/**/*.js" filters="ipFilter"></filter-chain>
	  		<filter-chain pattern="/icons/**" filters="ipFilter"></filter-chain>
	  		<filter-chain pattern="/common/**" filters="ipFilter"></filter-chain>
	  		<filter-chain pattern="/ext-4/**" filters="ipFilter"></filter-chain>
	  		<filter-chain pattern="/login.jsp" filters="ipFilter"></filter-chain>
	  		<filter-chain pattern="/**/*.swf" filters="none"></filter-chain>
	  		<filter-chain pattern="/loginFailure.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/accessDeny.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/timeout.jsp" filters="none"></filter-chain>
	  		<!-- <filter-chain pattern="/j_spring_security_check" filters="none"></filter-chain> -->
	  		<!-- http://mark.koli.ch/2010/07/spring-3-and-spring-security-setting-your-own-custom-j-spring-security-check-filter-processes-url.html -->
            <filter-chain pattern="/**" filters="
            	ipFilter,
               concurrentSessionFilter,
	           securityContextPersistenceFilterWithASCTrue,
	           logoutFilter,
	           usernamePasswordAuthenticationFilter,
	           rememberMeAuthenticationFilter,
	           sessionManagementFilter,
	           exceptionTranslationFilter,
	           filterSecurityInterceptor,
	           switchUserFilter" />
        </beans:list>
       </beans:constructor-arg>
	</beans:bean>
	<!-- ======================================华丽的分割线==============================================-->
	<beans:bean class="com.mawujun.user.login.IpFilter" name="ipFilter">
		<beans:property name="denyUrl" value="/accessDeny.jsp" />
		<beans:property name="ipBlacklists">
			<beans:list>
				<beans:bean class="com.mawujun.user.login.IpBlacklist">
					<beans:property name="url" value="/**"></beans:property>
					<!-- 现在是制定一个网段，也可以制定一个网址 172.16.5.5 -->
					<beans:property name="ip" value="172.16.5.5/24"></beans:property>
				</beans:bean>
			</beans:list>
		</beans:property>
	</beans:bean>
	<!-- ======================================华丽的分割线==============================================-->
	<beans:bean class="org.springframework.security.web.context.SecurityContextPersistenceFilter" name="securityContextPersistenceFilterWithASCTrue">
		<!--true在过滤器开始之前保证session是可用的，默认是false -->
		<beans:property name="forceEagerSessionCreation" value="false"></beans:property>
		<!-- 安全上下文存放的地方 -->
		<beans:property name="securityContextRepository"  ref="securityContextRepository" />
	</beans:bean>
	<!-- 生成HttpSessionSecurityContextRepository ，它会把安全上下文保存为一个HttpSession的属性
	可选的是，你可以提供一个SecurityContextRepository接口的 null实现，这就可以防止安全上下文被保存，即使一个session已经在请求期间被创建了。-->  
    <beans:bean id="securityContextRepository"   class="org.springframework.security.web.context.HttpSessionSecurityContextRepository">  
        <beans:property name="allowSessionCreation" value="true" />  
        <beans:property name="disableUrlRewriting" value="false" />  
    </beans:bean>  
	<!-- ======================================华丽的分割线==============================================-->
	<!-- <beans:bean class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler"> -->
	<beans:bean name="contentNavigationAuthenticationFailureHandler" class="com.mawujun.user.login.ContentNavigationAuthenticationFailureHandler">
		<beans:property name="defaultFailureUrl" value="/loginFailure.jsp"></beans:property>
		<beans:property name="redirectStrategy" ref="redirectStrategy">
		</beans:property>
		<!-- 是否使用forword来转发请求 ，使用forword的话，就可以再前台获取到请求数据和异常信息，默认是false -->
		<!-- 设置成true后，就可以通过request.getAttribute(WebAttributes.AUTHENTICATION_EXCEPTION);获取到异常信息
		否则就放在session中 -->
		<beans:property name="useForward" value="true"></beans:property> 
	</beans:bean>
	<beans:bean class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter" name="usernamePasswordAuthenticationFilter">
		<beans:property name="filterProcessesUrl" value="/j_spring_security_check"></beans:property><!-- 认证地址 -->
		<beans:property name="authenticationManager" ref="authenticationManager"></beans:property>
		<beans:property name="postOnly" value="false"></beans:property>
		<beans:property name="authenticationSuccessHandler"><!-- 认证成功的时候跳转-->
			<!-- <beans:bean class="org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler">
			<beans:bean class="org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler"> -->
			<beans:bean class="com.mawujun.user.login.SavedRequestAwareAuthenticationSuccessHandlerImpl"> 
				<beans:property name="defaultTargetUrl" value="/index.jsp"></beans:property>
				<beans:property name="requestCache" ref="httpSessionRequestCache"></beans:property>
				<!-- 更新用户的登录信息 最经的登录时间和登录ip-->
				<beans:property name="userService" ref="userService"></beans:property>
			</beans:bean>
		</beans:property>
		<beans:property name="authenticationFailureHandler" ref="contentNavigationAuthenticationFailureHandler"><!-- 认证失败的时候跳转，还有ExceptionMappingAuthenticationFailureHandler根据不同的异常跳转到不同的也页面-->	
		</beans:property>
		<!-- session的并发控制 ，往SessionRegistry中注册会话信息，到时候可以供给concurrentSessionFilter判断是否已经过期，就可以跳转到过期页面了-->
		<beans:property name="sessionAuthenticationStrategy" ref="concurrentSessionControlStrategy"></beans:property>
		<!-- 当登录成功后，就记录登录成功信息 -->
		<beans:property name="rememberMeServices" ref="rememberMeServices"></beans:property>
	</beans:bean>
	<beans:bean name="redirectStrategy" class="com.mawujun.user.login.ContentNavigationDefaultRedirectStrategy"></beans:bean>
	<!-- 实现了UserDetailsService的Bean -->  
    <authentication-manager alias="authenticationManager">  
        <authentication-provider user-service-ref="userDetailsService">  
        	 <password-encoder ref="passwordEncoder">  
             </password-encoder> 
            <!-- 登入 密码  采用MD5加密 
            <password-encoder hash="md5" ref="passwordEncoder">  
            </password-encoder>   --> 
        </authentication-provider>  
        <!-- rememberMe的认证提供者 -->
        <authentication-provider ref="rememberMeAuthenticationProvider"></authentication-provider>
    </authentication-manager>  
    
    <!-- 自定义UserDetailsService认证  -->   
    <beans:bean id="userDetailsService"   class="com.mawujun.user.login.UserDetailsServiceImpl">  
        <beans:property name="userService" ref="userService">
        </beans:property>  
        <beans:property name="rolePrefix" value="ROLE_"></beans:property>
    </beans:bean>  
  
    <!-- 用户的密码加密或解密org.springframework.security.authentication.encoding.Md5PasswordEncoder,这个类的接口已经不推荐使用了 ,但还可以使用-->  
    <!--  UserController类也依赖这个类进行加密，在创建用户登录和更改密码的时候-->  
    <beans:bean id="passwordEncoder"  class="org.springframework.security.crypto.password.NoOpPasswordEncoder" />  
    
    
    
    
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 异常处理过滤器 --> 
	<beans:bean class="org.springframework.security.web.access.ExceptionTranslationFilter" name="exceptionTranslationFilter">
		<beans:constructor-arg>
			<!--
			<beans:bean class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">-->
			<beans:bean class="com.mawujun.user.login.ContentNavigationLoginUrlAuthenticationEntryPoint">
				<beans:property name="loginFormUrl" value="/login.jsp"></beans:property><!-- 没有认证的时候，跳转 -->
			</beans:bean>
		</beans:constructor-arg>
		<!-- 当访问拒绝或会话超期的时候（注意不包括会话失效），记录这次访问的请求，等重新登录后，就会返回这个请求，通过RequestCacheAwareFilter -->
		<beans:constructor-arg ref="httpSessionRequestCache"></beans:constructor-arg>
		
		<beans:property name="accessDeniedHandler"><!--访问局拒绝的时候跳转
			<beans:bean class="org.springframework.security.web.access.AccessDeniedHandlerImpl">-->
			<beans:bean class="com.mawujun.user.login.ContentNavigationAccessDeniedHandlerImpl">
				<beans:property name="errorPage" value="/accessDeny.jsp"></beans:property>
			</beans:bean>
		</beans:property>
	</beans:bean>
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 自定义认证管理,资源,权限   
	<beans:bean class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor" name="filterSecurityInterceptor"> -->
	<beans:bean class="com.mawujun.user.login.FilterSecurityInterceptorImpl" name="filterSecurityInterceptor">
		<beans:property name="authenticationManager" ref="authenticationManager"></beans:property>
		<beans:property name="accessDecisionManager">
			<beans:bean class="com.mawujun.user.login.UnanimousBasedImpl"><!-- 全部同意才同意 -->
				<!--投票器具有双重判断，首先判断这个投票器惨不参与投票，如果参与再使用投票决策器，一票通过，大部分同意，或一票不通过就不通过策略-->	
				<!-- 当一个地址即符合RoleVoter，也符合AuthenticatedVoter的时候，一票通过该怎么办？所以对于菜单一定要注意进行AuthenticatedVoter投票的时候一定要进行 RoleVoter投票-->
				<beans:property name="decisionVoters">
					<beans:list>
						<beans:bean class="org.springframework.security.access.vote.RoleVoter">
							<!-- 和前面的userDetailsService进行对应，还有FilterInvocationSecurityMetadataSourceImpl，一共三个地方 ，rolePrefix表示，只有这些内容才进行投票，否则就通过其他投票器进行判断-->
							<beans:property name="rolePrefix" value="ROLE_"></beans:property>
						</beans:bean>
						<!-- 实际上AuthenticatedVoter只会对IS_AUTHENTICATED_FULLY、IS_AUTHENTICATED_REMEMBERED、IS_AUTHENTICATED_ANONYMOUSLY三种权限做vote处理
						supports方法 -->
						<beans:bean class="org.springframework.security.access.vote.AuthenticatedVoter">
						</beans:bean>

					</beans:list>
				</beans:property>		
			</beans:bean>
		</beans:property>
		<beans:property name="securityMetadataSource" ref="filterInvocationSecurityMetadataSourceImpl"><!-- 实现了角色资源的对应关系 -->
			
		</beans:property>
		<!-- 当某个资源被访问时，发现没有 授予角色时，也就是还没有进行分配的时候，是拒绝还是允许true是拒绝，
		-->
		<beans:property name="rejectPublicInvocations" value="true"></beans:property>
	</beans:bean>
	<!--RoleFunController也依赖这个类，用来更新这个对象的权限的 -->
	<beans:bean name="filterInvocationSecurityMetadataSourceImpl" class="com.mawujun.user.login.FilterInvocationSecurityMetadataSourceImpl">
				<beans:property name="rolePrefix" value="ROLE_"></beans:property>
				<beans:property name="roleService" ref="roleService"></beans:property>
				<!-- 定义了认证用户可以访问的范围，翻过来说匹配的地址必须是认证用户才能访问，
					1：还有能匿名的可定可以remember me访问，能remember me访问的可定可以认证后访问。
					2：认证可以访问的url，必须还要通过投票器进行决定才能确认是不是真的能访问，所以菜单url必须在authenticatedFullyUrls的范围之内或者通过AbstractAccessDecisionManager进行控制
					3：rejectPublicInvocations属性表示在这些资源之外的内容，也就是没有在控制范围内的url，默认是允许访问还是拒绝访问
					4：相当于是三种情况控制，认证就可以访问（三种认证）,必须授权才可以访问，其他的没有在前面两个范围内的访问控制。还可以再添加IP地址的控制（投票）-->
					<!-- d定义成remember级别，这样完全认证就可以访问了，如果定义成完全认证级别的话，在remember和完全认证不区分的情况下，rememberme登录的时候就访问不了，会拒绝访问 -->
				 <!-- 这里还可以扩展/download/**这些内容必须是谁可以访问的，也可以做成在页面上动态配置 -->
				 <beans:property name="authenticatedUrls">
					<beans:list>
						<beans:bean class="com.mawujun.user.login.AutheTypeSecurityConfig">
							<beans:property name="url" value="/**"></beans:property>
							<!-- IS_AUTHENTICATED_FULLY,IS_AUTHENTICATED_REMEMBERED,IS_AUTHENTICATED_ANONYMOUSLY -->
							<beans:property name="autheType" value="IS_AUTHENTICATED_REMEMBERED"></beans:property>
						</beans:bean>
					</beans:list>
				</beans:property>
	</beans:bean>
	<util:list id="roleFunObservers" list-class="java.util.ArrayList">  
	  <beans:ref bean="filterInvocationSecurityMetadataSourceImpl"/>
	</util:list>

	<!-- ======================================华丽的分割线==============================================-->
	<!-- 注销过滤器 -->
	<beans:bean id="logoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter">
		<beans:constructor-arg value="/login.jsp" />
		<beans:constructor-arg>
			<beans:array>
				<!-- 注销监听器  -->
				<beans:ref bean="logoutHandler" />	
				<!--注入rememberMeServices属性是为了安全退出的时候把记住密码的状态也删除了-->
				<beans:ref bean="rememberMeServices" />
			</beans:array>
		</beans:constructor-arg>
		<beans:property name="filterProcessesUrl" value="/j_spring_security_logout" />
	</beans:bean>
	<!-- 注销监听器,多个地方引用了  -->
	<beans:bean id="logoutHandler" class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"></beans:bean>





	<!-- ======================================华丽的分割线==============================================-->	
	<!-- SESSION固化保护,以及并发控制 -->
	<beans:bean id="sessionManagementFilter" class="org.springframework.security.web.session.SessionManagementFilter">
		<beans:constructor-arg name="securityContextRepository" ref="securityContextRepository" />
		<beans:property name="sessionAuthenticationStrategy" ref="concurrentSessionControlStrategy" />
	</beans:bean>

	<!-- SESSION并发数量等配置 -->
	<beans:bean id="concurrentSessionControlStrategy" class="org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy">
		<beans:constructor-arg name="sessionRegistry">
			<beans:ref bean="sessionRegistry" />	
		</beans:constructor-arg>
		<!-- 要求UserDetailsImpl实现hashCode和equals方法，来获取到唯一的对象 -->
		<beans:property name="maximumSessions" value="1" /><!-- 控制同个账号登录的次数，-1表示没有限制 -->
		<beans:property name="exceptionIfMaximumExceeded" value="false" /><!-- 表示将前面已经存在的用户强制过期，true表示后来的用户登录不了 -->
	</beans:bean>
	<beans:bean id="sessionRegistry" class="org.springframework.security.core.session.SessionRegistryImpl" />
	<!-- 过期会话的处理工作 -->
	<beans:bean id="concurrentSessionFilter" class="org.springframework.security.web.session.ConcurrentSessionFilter">
		<beans:constructor-arg ref="sessionRegistry">			
		</beans:constructor-arg>
		<!-- 这里的过期主要用于强制过期的时候，如果是web服务器过期是不会走这条线的。或者是同个账号不能同时登陆的时候，强制用户失效后再进行访问的时候跳转的页面 -->
		<beans:property name="expiredUrl" value="/timeout.jsp" />
		<beans:property name="redirectStrategy" ref="redirectStrategy"></beans:property>
		<beans:property name="logoutHandlers">
			<beans:list>
				<beans:ref bean="logoutHandler" />
				<!-- 这个要在 exceptionIfMaximumExceeded=false的时候配置，或者拥有强制用户失效（不是过期）-->
				<beans:bean class="com.mawujun.user.login.SavedRequestConcurrentSessionLogoutHandler">
					<beans:constructor-arg ref="httpSessionRequestCache"></beans:constructor-arg>
				</beans:bean>
			</beans:list>
		</beans:property>
	</beans:bean>
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 用于用户登录成功后，重新恢复因为登录被打断的请求,
	简单点说就是出现了AuthenticationException、AccessDeniedException两类异常 重新恢复：
	<beans:bean name="requestCacheAwareFilter" class="org.springframework.security.web.savedrequest.RequestCacheAwareFilter">
		<beans:constructor-arg ref="httpSessionRequestCache">
		</beans:constructor-arg>
	</beans:bean> 不需要这儿过滤器，
	1：只需要在UsernamePasswordAuthenticationFilter设置authenticationSuccessHandler为SavedRequestAwareAuthenticationSuccessHandler
	2： 设置ExceptionTranslationFilter的httpSessionRequestCache-->
	<!-- 存储上次请求的URL-->
	<beans:bean name="httpSessionRequestCache" class="org.springframework.security.web.savedrequest.HttpSessionRequestCache">
	</beans:bean>
	
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 记住密码功能(COOKIE方式) -->
	<beans:bean id="rememberMeAuthenticationFilter" class="org.springframework.security.web.authentication.rememberme.RememberMeAuthenticationFilter">
		<beans:property name="rememberMeServices" ref="rememberMeServices" />
		<beans:property name="authenticationManager" ref="authenticationManager" />
	</beans:bean>
	<!-- 一种是客户端记住用户名密码，一种是服务端记住用户名密码，现在采用的是客户端记住用户名密码 -->
	<beans:bean id="rememberMeServices" class="org.springframework.security.web.authentication.rememberme.TokenBasedRememberMeServices">
		<beans:property name="userDetailsService" ref="userDetailsService" />
		<!-- 前台勾选是否记住用户名密码的参数，当 alwaysRemember=false的时候才会有用-->
		<beans:property name="parameter" value="rememberMe" />
		<!-- 表示肯定要记住用户名密码 -->
		<beans:property name="alwaysRemember" value="false"></beans:property>
		<!-- 默认时间604800秒(一个星期) -->
		<beans:property name="tokenValiditySeconds" value="604800" />
		<beans:property name="key" value="springRocks" />
	</beans:bean>
	<!--添加到 <authentication-manager alias="authenticationManager">中，作为第二种认证提供者的方式  -->
	<beans:bean id="rememberMeAuthenticationProvider" class="org.springframework.security.authentication.RememberMeAuthenticationProvider">
		<beans:property name="key" value="springRocks" />
	</beans:bean>
	
	<!-- ======================================华丽的分割线==============================================-->
	<!-- 在不知道用户密码的情况下，可以切换到另一个用户上，可以动态变换权限，非常适合于测试 -->
	<beans:bean id="switchUserFilter" class="com.mawujun.user.login.SwitchUserFilterImpl">
		<beans:property name="userDetailsService" ref="userDetailsService" />
		<beans:property name="switchUserUrl" value="/j_spring_security_switch_user" />
		<beans:property name="exitUserUrl" value="/j_spring_security_exit_user" />
		<beans:property name="targetUrl" value="/index.jsp" />
		<!-- <beans:property name="switchFailureUrl" value="/loginFailure.jsp" /> 已经在contentNavigationAuthenticationFailureHandler定义好了 -->
		<beans:property name="failureHandler" ref="contentNavigationAuthenticationFailureHandler" />
	</beans:bean>
	
	<!-- DefaultWebInvocationPrivilegeEvaluator页面标签的权限 -->
	
    
</beans:beans> 