<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/security"  
    xmlns:beans="http://www.springframework.org/schema/beans"   
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
	xsi:schemaLocation="http://www.springframework.org/schema/beans   
	http://www.springframework.org/schema/beans/spring-beans-3.0.xsd    
	http://www.springframework.org/schema/security   
	http://www.springframework.org/schema/security/spring-security-3.1.xsd">  
    <!-- 
    <global-method-security pre-post-annotations="enabled"></global-method-security>  .
     -->
    <!-- 该路径下的资源不用过滤  
    <http pattern="/icons/**" security="none" />  
    <http pattern="/common/**" security="none" />  
    <http pattern="/ext-4/**" security="none" />  
    <http pattern="/login.jsp" security="none" />  http://zhoualine.iteye.com/blog/1755233   http://blog.csdn.net/shadowsick/article/details/8576449#
    --> 

    <!-- 这个id要和web.xml中的配置一样，否则会爆No bean named 'springSecurityFilterChain' is defined的异常 -->
    <!-- 一些路不进行过滤的配置还没有写 -->
    <beans:bean id="springSecurityFilterChain" class="org.springframework.security.web.FilterChainProxy">
	  <!--<filter-chain-map path-type="ant">
	     <filter-chain pattern="/**" filters="
	           securityContextPersistenceFilterWithASCTrue,
	           usernamePasswordAuthenticationFilter,
	           exceptionTranslationFilter,
	           filterSecurityInterceptor" />
	           
	  </filter-chain-map> 
	  -->
	  <beans:constructor-arg> 
	  	<beans:list>  
	  		<filter-chain pattern="/**/*.js" filters="none"></filter-chain>
	  		<filter-chain pattern="/icons/**" filters="none"></filter-chain>
	  		<filter-chain pattern="/common/**" filters="none"></filter-chain>
	  		<filter-chain pattern="/ext-4/**" filters="none"></filter-chain>
	  		<filter-chain pattern="/login.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/loginFailure.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/accessDeny.jsp" filters="none"></filter-chain>
	  		<filter-chain pattern="/timeout.jsp" filters="none"></filter-chain>
	  		<!-- <filter-chain pattern="/j_spring_security_check" filters="none"></filter-chain> -->
	  		<!-- http://mark.koli.ch/2010/07/spring-3-and-spring-security-setting-your-own-custom-j-spring-security-check-filter-processes-url.html -->
            <filter-chain pattern="/**" filters="
               concurrentSessionFilter,
	           securityContextPersistenceFilterWithASCTrue,
	           logoutFilter,
	           usernamePasswordAuthenticationFilter,
	           sessionManagementFilter,
	           exceptionTranslationFilter,
	           filterSecurityInterceptor" />
        </beans:list>
       </beans:constructor-arg>
	</beans:bean>
	
	<beans:bean class="org.springframework.security.web.context.SecurityContextPersistenceFilter" name="securityContextPersistenceFilterWithASCTrue">
		<!--true在过滤器开始之前保证session是可用的，默认是false -->
		<beans:property name="forceEagerSessionCreation" value="false"></beans:property>
		<!-- 安全上下文存放的地方 -->
		<beans:property name="securityContextRepository"  ref="securityContextRepository" />
	</beans:bean>
	<!-- 生成HttpSessionSecurityContextRepository ，它会把安全上下文保存为一个HttpSession的属性
	可选的是，你可以提供一个SecurityContextRepository接口的 null实现，这就可以防止安全上下文被保存，即使一个session已经在请求期间被创建了。-->  
    <beans:bean id="securityContextRepository"   class="org.springframework.security.web.context.HttpSessionSecurityContextRepository">  
        <beans:property name="allowSessionCreation" value="true" />  
        <beans:property name="disableUrlRewriting" value="false" />  
    </beans:bean>  
	
	
	<beans:bean class="org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter" name="usernamePasswordAuthenticationFilter">
		<beans:property name="filterProcessesUrl" value="/j_spring_security_check"></beans:property><!-- 认证地址 -->
		<beans:property name="authenticationManager" ref="myAuthenticationManager"></beans:property>
		<beans:property name="postOnly" value="false"></beans:property>
		<beans:property name="authenticationSuccessHandler"><!-- 认证成功的时候跳转-->
			<beans:bean class="org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler">
				<beans:property name="defaultTargetUrl" value="/index.jsp"></beans:property>
			</beans:bean>
		</beans:property>
		<beans:property name="authenticationFailureHandler"><!-- 认证失败的时候跳转-->
			<beans:bean class="org.springframework.security.web.authentication.SimpleUrlAuthenticationFailureHandler">
				<beans:property name="defaultFailureUrl" value="/loginFailure.jsp"></beans:property>
				<beans:property name="redirectStrategy">
					<beans:bean class="com.mawujun.user.login.AjaxRedirectStrategy">
					</beans:bean>
				</beans:property>	
			</beans:bean>
		</beans:property>
		<!-- session的并发控制 ，往SessionRegistry中注册会话信息，到时候可以供给concurrentSessionFilter判断是否已经过期，就可以跳转到过期页面了-->
		<beans:property name="sessionAuthenticationStrategy" ref="concurrentSessionControlStrategy"></beans:property>
	</beans:bean>
	<!-- 异常处理过滤器 --> 
	<beans:bean class="org.springframework.security.web.access.ExceptionTranslationFilter" name="exceptionTranslationFilter">
		<beans:property name="authenticationEntryPoint">
			<beans:bean class="org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint">
				<beans:property name="loginFormUrl" value="/login.jsp"></beans:property><!-- 没有认证的时候，跳转 -->
			</beans:bean>
		</beans:property>
		<beans:property name="accessDeniedHandler"><!--访问局拒绝的时候跳转-->
			<beans:bean class="org.springframework.security.web.access.AccessDeniedHandlerImpl">
				<beans:property name="errorPage" value="/accessDeny.jsp"></beans:property>
			</beans:bean>
		</beans:property>
	</beans:bean>
	<!-- 自定义认证管理,资源,权限   
	<beans:bean class="org.springframework.security.web.access.intercept.FilterSecurityInterceptor" name="filterSecurityInterceptor"> -->
	<beans:bean class="com.mawujun.user.login.FilterSecurityInterceptorImpl" name="filterSecurityInterceptor">
		<beans:property name="authenticationManager" ref="myAuthenticationManager"></beans:property>
		<beans:property name="accessDecisionManager">
			<beans:bean class="com.mawujun.user.login.AffirmativeBasedImpl">
				<!--取消了投票器，因为这里没有实现反向授权-->	
				<beans:property name="decisionVoters">
					<beans:list>
						<beans:bean class="org.springframework.security.access.vote.RoleVoter">
							<beans:property name="rolePrefix" value=""></beans:property>
						</beans:bean>
					</beans:list>
				</beans:property>		
			</beans:bean>
		</beans:property>
		<beans:property name="securityMetadataSource"><!-- 实现了角色资源的对应关系 -->
			<beans:bean class="com.mawujun.user.login.FilterInvocationSecurityMetadataSourceImpl">
				<beans:property name="roleService" ref="roleService"></beans:property>
				<!-- 必须要认证过才能访问的URL配置，roleService中获取的资源就表示认证后还不一定可以昂问，也就是说roleService的内容必须认证才能访问，但认证后不一定能访问roleService中返回的内容
				 这些地址之外的就表示无论谁都可以访问。-->
				<beans:property name="needAuthenticationUrls">
					<beans:list>
						<beans:value>/**</beans:value>
					</beans:list>
				</beans:property>
			</beans:bean>
		</beans:property>
		<!-- 当某个资源被访问时，发现没有 授予他时，是拒绝还是允许-->
		<beans:property name="rejectPublicInvocations" value="false"></beans:property>
	</beans:bean>
	
	<!-- 注销过滤器 -->
	<beans:bean id="logoutFilter" class="org.springframework.security.web.authentication.logout.LogoutFilter">
		<beans:constructor-arg value="/login.jsp" />
		<beans:constructor-arg>
			<beans:array>
				<!-- 注销监听器  -->
				<beans:ref bean="logoutHandler" />	
				<!--注入rememberMeServices属性是为了安全退出的时候把记住密码的状态也删除了
				<ref bean="rememberMeServices" />-->
			</beans:array>
		</beans:constructor-arg>
		<beans:property name="filterProcessesUrl" value="/j_spring_security_logout" />
	</beans:bean>
	<!-- 注销监听器  -->
	<beans:bean id="logoutHandler" class="org.springframework.security.web.authentication.logout.SecurityContextLogoutHandler"></beans:bean>

	
	<!-- SESSION固化保护,以及并发控制 -->
	<beans:bean id="sessionManagementFilter" class="org.springframework.security.web.session.SessionManagementFilter">
		<beans:constructor-arg name="securityContextRepository" ref="securityContextRepository" />
		<beans:property name="sessionAuthenticationStrategy" ref="concurrentSessionControlStrategy" />
	</beans:bean>

	<!-- SESSION并发数量等配置 -->
	<beans:bean id="concurrentSessionControlStrategy" class="org.springframework.security.web.authentication.session.ConcurrentSessionControlStrategy">
		<beans:constructor-arg name="sessionRegistry">
			<beans:ref bean="sessionRegistry" />	
		</beans:constructor-arg>
		<!-- 要求UserDetailsImpl实现hashCode和equals方法，来获取到唯一的对象 -->
		<beans:property name="maximumSessions" value="1" /><!-- 控制同个账号登录的次数，-1表示没有限制 -->
		<beans:property name="exceptionIfMaximumExceeded" value="false" /><!-- 表示将前面已经存在的用户强制过期，true表示后来的用户登录不了 -->
	</beans:bean>
	<beans:bean id="sessionRegistry" class="org.springframework.security.core.session.SessionRegistryImpl" />
	<!-- 过期会话的处理工作 -->
	<beans:bean id="concurrentSessionFilter" class="org.springframework.security.web.session.ConcurrentSessionFilter">
		<beans:property name="sessionRegistry" ref="sessionRegistry" />
		<!-- 这里的过期主要用于强制过期的时候，如果是web服务器过期是不会走这条线的。或者是同个账号不能同时登陆的时候，强制用户失效后再进行访问的时候跳转的页面 -->
		<beans:property name="expiredUrl" value="/timeout.jsp" />
		<beans:property name="logoutHandlers">
			<beans:list>
				<beans:ref bean="logoutHandler" />
			</beans:list>
		</beans:property>
	</beans:bean>
	

	
	<!-- DefaultWebInvocationPrivilegeEvaluator页面标签的权限 -->
	
    <!-- 实现了UserDetailsService的Bean -->  
    <authentication-manager alias="myAuthenticationManager">  
        <authentication-provider user-service-ref="myUserDetailServiceImpl">  
            <!-- 登入 密码  采用MD5加密 
            <password-encoder hash="md5" ref="passwordEncoder">  
            </password-encoder>   --> 
        </authentication-provider>  
    </authentication-manager>  
    
    <!-- 自定义UserDetailsService认证  -->   
    <beans:bean id="myUserDetailServiceImpl"  
        class="com.mawujun.user.login.UserDetailsServiceImpl">  
        <beans:property name="userService" ref="userService"></beans:property>  
    </beans:bean>  
  
    <!-- 用户的密码加密或解密 -->  
    <beans:bean id="passwordEncoder"  
		class="org.springframework.security.authentication.encoding.Md5PasswordEncoder" />  
</beans:beans> 